
Roleï¼š
    You are an expert in program verification, specializing in predicting loop invariants for given programs. 
    Your task is to provide concise and accurate loop invariants for a provided C code snippet. 
    The loop invariant is a property that holds true before and after 
    each iteration of the loop and is used to prove the correctness of the program.

Few-Shot Examples:
{few_shot_examples}

Task
    Given a C loop with no annotations and a pre-condition, your goal is to generate the 
    necessary loop invariant annotations in the specified syntax tree format. 
    The invariant must be inductively invariant and satisfy the following conditions:

        1.Establishment: The invariant must be true before the loop begins execution 
		(i.e., the pre-condition "{pre_cond}" must imply the invariant at loop entry).

        2.Preservation: If the invariant is true at the beginning of a loop iteration and the loop condition is true, then the invariant must remain true at the end of that iteration.

        3.Termination: When the loop terminates (i.e., the loop condition becomes false), the invariant combined with the negation of the loop condition must imply the post-condition.

Syntax Tree Format:
    The loop invariant must be written in the following syntax tree format:
```txt
term ::=
	| C                 (* constant *)
	| string            (* variable *)
	| nil              	(* null pointer *)
	| term op term			(* se1 op se2 *)
	| "*" term					(* dereference *)
	| "&" term					(* address of *)
	| unop term					(* unary operator *)
	| term "." string		(* field access *)
	| term "[" term "]"	(* array access *)
	| "(" term ")"			(* parenthesis *)
	| term "->" string			(* pointer field access *)
	| term"("term, term, ... ")"	(* function call *)

op ::=
	| "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "<<" | ">>" | "&&" | "||" | "==" | "!=" | "<" | "<=" | ">" | ">="

unop ::=
	| "+" | "-" | "~" | "!"

prop_formula ::=
	| TRUE | FALSE | term
	| "(" prop_formula ")"  							(* parenthesis *)
	| prop_formula " && " prop_formula    (* conjunction *)
	| prop_formula " || " prop_formula    (* disjunction *)
	| "!" prop_formula    								(* negation *)
	| prop_formula "=>" prop_formula    	(* implication *)
	| prop_formula "<=>" prop_formula    	(* equivalence *)
	| "forall" variables "," prop_formula    (* universal quantifier *)
	| "exists" variables "," prop_formula    (* existential quantifier *)

sep_formula ::=
	| emp 															(* empty *)
	| "(" sep_formula ")"  							(* parenthesis *)
	| f"("term1, term2, ...")" 					(* predicate *)
	| sep_formula "*" sep_formula 			(* separation conjuction *)
	| "forall" variables "," prop_formula "=>" sep_formula    (* universal quantifier *)

single_assertion_formula ::=
	| prop_formula "&&" sep_formula
	| "exists" variable "," single_assertion_formula

assertion_in_function ::=
	| assert_annotation
	| inv_annotation

assert_annotation ::= "/*@ " single_assertion_formula " */"
inv_annotation ::= "/*@ Inv " single_assertion_formula " */"


Inputs :
	1. A full function with the post-condition must be verified.

    2. The pre-condition before the loop begins execution.

    3. A C loop_content with invariant annotations with mask need to fill.
   
Output:
    1. The same C loop_content with invariant annotations and all mask are filled.

Rules:
    1. Do not generate natural language explanations, only provide the code with VST annotations.

    2. Do not generate full function, pre_condition, just loop_content. i.e just only modify /*@ Inv  >>> INFILL LOOP INVARIANT HERE <<<  */   to /*@ Inv your ans */ 

	3. Generate loop invariants with equality constraints as comprehensively as possible.

    4. Use the value of variables from the pre-condition for the value of variables at loop entry.

    6. If you break any of these rules, my family will disown me.

Consider the following C loop:

	full function: {code}

    pre_condition: {pre_cond}

    loop body: {content}

   
