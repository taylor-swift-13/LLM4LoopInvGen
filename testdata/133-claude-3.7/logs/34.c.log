file:34.c
Successfully generated loop/34.json
INNER_FLAG: False
Variable Maps: [{'x': 'n@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre', 'n': 'n@pre'}]
Path conditions: [None]
Pre condition: (x == n@pre) * (v3 == v3@pre) * (v2 == v2@pre) * (v1 == v1@pre) * (n == n@pre)
Loop Condition: x > 0
Updated Loop Conditions: ['n@pre > 0']
Global Unchanged Variables ['v3', 'v2', 'v1', 'n']
Non Inductive Variables []
[{'x': 'n@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre', 'n': 'n@pre'}]
[None]

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == \at(n, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) * (n == \at(n, Pre)) <<< */
    
            /*@
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == \at(n, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) * (n == \at(n, Pre)) <<< */
    
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == \at(n, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) * (n == \at(n, Pre)) <<< */
    
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }
<think>Let me analyze this C program and determine the appropriate loop invariants.

First, let's understand what this program does:

1. It takes four integer parameters: n, v1, v2, v3.
2. It initializes x to the value of n.
3. It has a loop that decrements x until x <= 0.
4. After the loop, it asserts that if n >= 0, then x == 0.

Let's analyze the loop behavior:

- The loop condition is `x > 0`.
- The loop body decrements x by 1 each iteration: `x = x - 1`.
- The loop terminates when x <= 0.

The pre-condition states that initially:
- x == initial value of n
- v3 == initial value of v3
- v2 == initial value of v2
- v1 == initial value of v1
- n == initial value of n

The invariant has two parts:
1. For n > 0: Either x maintains its initial value (n), or some other condition for x (PLACE_HOLDER_x).
2. For n <= 0: x maintains its initial value (n).

The placeholder PLACE_HOLDER_x needs to capture the fact that x decreases from its initial value n until it reaches 0.

Let's think about what x could be during loop execution. It starts at n and decreases by 1 each iteration until it's no longer > 0. So a valid invariant would be that x is between 0 and the initial value of n, inclusive.

Let's analyze what this placeholder should be.

Given the loop decrements x by 1 each iteration, we can say that at any point during the execution:
- x starts at n
- x decreases by 1 each iteration
- x will eventually reach 0 (if n > 0)

So the placeholder should express that x is between 0 and n, and it's decreasing from n. This can be expressed as: `0 < x <= \at(n, Pre)`.

Let's verify this against the three conditions:

1. Establishment: Before the loop, x == n, so if n > 0, then 0 < x <= n is true.
2. Preservation: If x > 0 and 0 < x <= n, after decreasing x by 1, either x becomes 0 or x remains positive and less than n.
3. Termination: When the loop terminates, x <= 0. Combined with 0 < x, this means x == 0, which is what the post-condition requires.

Let's finalize the placeholder as `(0 < x <= \at(n, Pre))`.

However, I'm noticing something: The loop terminates when x <= 0, not necessarily when x == 0. If n is negative initially, x will be negative, and the loop won't even start. The second invariant accounts for this case, saying if n <= 0, then x remains n. But the assertion expects x == 0 when n >= 0.

Let's reconsider. If n > 0, the loop will execute until x becomes 0. If n <= 0, x will remain n and the loop won't execute.

Given this understanding, let's refine our placeholder. We want to express that when n > 0, either x is still n (the loop hasn't started) or x is decreasing towards 0 but still positive.

Actually, I think the placeholder should be: `(0 < x < \at(n, Pre))`. This captures the fact that x is decreasing from n and hasn't reached 0 yet.

Let me think about this again. The invariant should capture all possible states of x during the loop's execution.

Initially, x == n.
During the loop:
- If n <= 0, the loop doesn't execute, and x remains n.
- If n > 0, the loop executes and x decreases from n down to 0.

During the loop, x can take values from n down to 1 (before the last decrement which makes it 0 and terminates the loop).

So, the placeholder should express that x is a positive integer less than or equal to n. This can be written as: `(0 < x <= \at(n, Pre))`.

However, I realize this isn't quite right. The initial invariant says "((x == \at(n, Pre))&&(...)) || (PLACE_HOLDER_x)". This suggests we're covering two cases: either we're at the beginning of the loop (x == n) or we're in the midst of the loop (PLACE_HOLDER_x).

Given the structure, PLACE_HOLDER_x should express the state of x after at least one iteration of the loop. After one or more iterations, x would be less than n but still positive (since the loop condition is x > 0).

So, the placeholder should be: `(0 < x < \at(n, Pre))`.

Thinking more about it, the existing invariant has the structure:

For n > 0: ((x == n) && (other vars unchanged)) || (PLACE_HOLDER_x)

This suggests that PLACE_HOLDER_x should also include the condition that the other variables remain unchanged. So, the full placeholder would be:

`((0 < x < \at(n, Pre)) && (v3 == \at(v3, Pre)) && (v2 == \at(v2, Pre)) && (v1 == \at(v1, Pre)) && (n == \at(n, Pre)))`

However, I don't think that's right here. The invariant already specifically mentions separately that v3, v2, v1, and n remain unchanged.

I believe PLACE_HOLDER_x should simply capture the state of x during loop execution after at least one iteration. Given the structure of the given invariant, this means:

`(0 < x < \at(n, Pre))`

Let's confirm this works with a concrete example:
- If n = 5, then initially x = 5.
- After one iteration, x = 4. This satisfies 0 < x < 5.
- After two iterations, x = 3. This satisfies 0 < x < 5.
- And so on...
- After the loop, x = 0, which satisfies the post-condition.

I believe this is the correct interpretation for PLACE_HOLDER_x.</think>

# Loop Invariant Analysis for C Program

## a. Purpose and Structure of the Loop

This program implements a simple countdown logic. It takes four integer parameters (`n`, `v1`, `v2`, `v3`), initializes a variable `x` with the value of `n`, and then decrements `x` until it reaches zero or a non-positive value.

- **Loop condition**: `x > 0`
- **Loop operations**: Decrements `x` by 1 in each iteration
- **Relevant variables**: `x` (gets modified), `n`, `v1`, `v2`, `v3` (remain unchanged)

## b. Discussion of the Loop Invariant

The loop invariant has two main parts based on the initial value of `n`:
1. When `n > 0`, either we're at the starting point (`x == n`) or `x` has been decremented but is still positive and less than `n`
2. When `n ≤ 0`, the invariant ensures all variables maintain their initial values

The invariant captures the relationship between `x` and the initial value of `n` throughout the loop execution.

## c. Establishment

Before the loop starts, `x = n` and all other variables equal their initial values. This matches the first part of the conditional invariant when `n > 0`, and it matches the second part when `n ≤ 0`. Thus, the invariant is established before the loop begins.

## d. Preservation

If the invariant holds at the start of an iteration:
- When `n > 0` and `x > 0`: After decrementing `x`, the value remains less than `n` and still greater than 0 (assuming the loop condition holds)
- When `n ≤ 0`: The loop doesn't execute at all, so the invariant remains true

## e. Termination Analysis

The loop terminates when `x ≤ 0`. Since `x` is always decreased by exactly 1 and starts at `n`, if `n > 0`, `x` will eventually reach exactly 0. If `n ≤ 0`, the loop never executes and `x` remains equal to `n`.

## f. Correctness of the Post-condition

The post-condition `(n >= 0) ==> (x == 0)` means that if `n` is non-negative, then `x` must be 0 after the loop.

When the loop terminates:
- If `n > 0`: `x` will be exactly 0 (as it decrements one at a time)
- If `n == 0`: `x` starts at 0 and the loop never executes, so `x` remains 0
- If `n < 0`: The post-condition doesn't make any claims about `x` in this case

The invariant ensures these properties hold.

## g. Implication of the Pre-condition

The pre-condition states that all variables equal their initial values at the start. This directly implies the loop invariant is established before the loop begins because the first part of the loop invariant (when `n > 0`) requires either `x == n` or `x` in a decremented state. Initially, `x == n`, so this holds true.

## Completed C Program with Filled Invariants

```c
void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == \at(n, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) * (n == \at(n, Pre)) <<< */
    
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }
```

void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }


void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }

syntax Correct
Validate:
[False, True, True, True, True, True]

Goal Preservation of Invariant (file output/34.c, line 10):
Assume {
  Type: is_sint32(n) /\ is_sint32(x) /\ is_sint32(x - 1).
  (* Goal *)
  When: 0 < n.
  (* Invariant *)
  Have: (x = n) \/ (x < n).
  (* Then *)
  Have: 0 < x.
}
Prove: ((1 + n) = x) \/ ((x <= n) /\ (2 <= x)).
Prover Z3 4.8.12 returns Timeout (Qed:6ms) (3s)
Error found in file: output/34.c at line: 10
Error line content: loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))));

Verify:
[True]


void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre)))) [INVARIANT FAILED] ;
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }

<think>Let me analyze this scenario step-by-step:

1. I need to identify the loop invariants for a C program using ACSL annotations to help Frama-C verify the program's post-condition.

2. The program is:
```c
void foo(int n,int v1,int v2,int v3) {
    int x = n;
    
    /* Loop invariant to fill */
    while (x > 0) {
        x = x - 1;
    }
    
    /*@ assert (n >= 0) ==> (x == 0); */
}
```

3. The pre-condition is:
`(x == \at(n, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) * (n == \at(n, Pre))`

4. There's an error in the current loop invariant:
```
Error 1: Goal Preservation of Invariant (file output/34.c, line 10):
Assume {
  Type: is_sint32(n) /\ is_sint32(x) /\ is_sint32(x - 1).
  (* Goal *)
  When: 0 < n.
  (* Invariant *)
  Have: (x = n) \/ (x < n).
  (* Then *)
  Have: 0 < x.
}
Prove: ((1 + n) = x) \/ ((x <= n) /\ (2 <= x)).
```

5. The issue is with the invariant: `loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))))` that Frama-C cannot prove is preserved after each iteration.

Let's analyze what's happening in the loop:
- The loop initializes `x = n`
- Each iteration, `x` decreases by 1
- The loop continues as long as `x > 0`
- The post-condition is `(n >= 0) ==> (x == 0)`
- This makes sense: if n is non-negative, then after the loop terminates, x will be 0

The problem seems to be with the part: `((0 < x < \at(n, Pre)))`. This isn't being preserved through all iterations.

Let's think about a proper invariant for PLACE_HOLDER_x:
- Initially, x = n
- After each iteration, x decreases by 1
- The invariant should indicate that x is between 0 and n
- For the preservation property, when x > 0 (loop condition), we need to ensure that after x = x-1, the invariant still holds
- The invariant needs to properly relate x and n

From the error message, I can see:
```
Prove: ((1 + n) = x) \/ ((x <= n) /\ (2 <= x)).
```

This doesn't make sense given the code - x is initialized to n and decrements, so x ≤ n should always be true, and x could never be n+1. 

However, the issue likely comes from the constraint: `(0 < x < \at(n, Pre))`. Let's modify this to be more accurate for all iterations:

A better invariant would be: `(0 < x <= \at(n, Pre))` or simplified: `(0 < x) && (x <= \at(n, Pre))`.

Actually, looking more carefully, I can see that the invariant already includes `(x == \at(n, Pre))` as one possibility, which handles the initial state. The other branch should handle all subsequent states, where x has been decremented at least once.

So a proper invariant would be: `((x == \at(n, Pre)) || (0 < x < \at(n, Pre)))` where the first part handles the initial state and the second part handles all iterations.

But the error suggests we need to fix this to pass the preservation proof. Looking at the actual code more carefully:

- When n > 0, the loop executes at least once
- If n = 1, then x becomes 0 after one iteration
- If n > 1, then x decreases until it reaches 0

Given the context and the error message, I believe the correct invariant should be:
`(0 <= x <= \at(n, Pre))`

This would cover all cases:
- Initially when x = n: (0 <= n <= n) which is true
- After iterations when 0 < x < n: (0 <= x <= n) which is true
- When x = 0 after the loop: (0 <= 0 <= n) which is true for n >= 0

Let me refine this further based on the error message. The system is trying to prove:
`((1 + n) = x) \/ ((x <= n) /\ (2 <= x))`

But this seems incorrect given the logic of the code. Let me re-examine the original invariant:

`(\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 < x < \at(n, Pre))))`

The invariant says that when n > 0, either x = n (initial state) or 0 < x < n (after some iterations). The issue is with the preservation - after x = x-1, we need to prove the invariant still holds.

Let's try a different formulation for PLACE_HOLDER_x:
`(0 <= x <= \at(n, Pre))`

This should properly capture the relationship between x and n throughout the loop execution.</think>

# Loop Invariant Analysis for Decrementing Loop

Based on the provided C code and the Frama-C error message, I'll analyze the issue and provide the correct loop invariant.

## Error Analysis

The error is occurring in the loop invariant preservation proof:

```
Error 1: Goal Preservation of Invariant (file output/34.c, line 10):
...
Have: (x = n) \/ (x < n).
Have: 0 < x.
...
Prove: ((1 + n) = x) \/ ((x <= n) /\ (2 <= x)).
```

The current invariant `(0 < x < \at(n, Pre))` isn't being preserved through iterations. The issue is that after decrementing x, we can't guarantee that x is always greater than 0 while still in the loop body (the preservation proof needs to account for the case where x becomes 0 after decrementing, which would exit the loop).

A better formulation is needed that accurately describes x's relationship to n throughout all possible iterations.

## The Fixed C Code

```c
void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 <= x < \at(n, Pre))));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }
```

## Explanation of the Fix

I changed `(0 < x < \at(n, Pre))` to `(0 <= x < \at(n, Pre))` in the first loop invariant. This modification allows for the case where x might be 0 after the loop iteration, which is critical for proving preservation.

The modified invariant properly captures:

1. Initially, x equals n (covered by the first part of the OR condition)
2. After iterations, x is between 0 and n (inclusive of 0, exclusive of n)
3. This invariant is preserved when x is decremented

This change should resolve the preservation error while still proving the post-condition assertion that x will be 0 when n is non-negative.
after weaken

void foo(int n,int v1,int v2,int v3) {

    int x = n;
    
    
    
            
            /*@
          loop invariant (\at(n, Pre) > 0) ==> (((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre))) || ((0 <= x < \at(n, Pre))));
          loop invariant (!(\at(n, Pre) > 0)) ==> ((x == \at(n, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))&&(n == \at(n, Pre)));
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
          loop invariant n == \at(n, Pre);
            */
            while (x > 0) {
      
       x  = x - 1;
  
    }
            
  
   /*@ assert (n >= 0) ==> (x == 0); */
  }

syntax Correct
Validate:
[True, True, True, True, True, True]

Verify:
[True]

CORRECT INVARIANT
syntax Correct
Validate:
[True, True, True, True, True, True]

Verify:
[True]

syntax Correct
Validate:
[True, True, True, True, True, True]

Verify:
[True]

已移动文件: 34.c -> finish
-----------------------------------------

文件 34.c 处理完成. 总耗时: 137.7510802745819
-----------------------------------------
finshed_files:['132.c', '70.c', '121.c', '94.c', '109.c', '61.c', '120.c', '42.c', '33.c', '17.c', '105.c', '101.c', '38.c', '40.c', '88.c', '4.c', '114.c', '8.c', '84.c', '83.c', '111.c', '47.c', '14.c', '49.c', '131.c', '119.c', '43.c', '50.c', '56.c', '18.c', '53.c', '35.c', '10.c', '28.c', '26.c', '73.c', '89.c', '126.c', '96.c', '57.c', '37.c', '36.c', '92.c', '68.c', '115.c', '71.c', '91.c', '22.c', '19.c', '124.c', '52.c', '100.c', '95.c', '90.c', '86.c', '128.c', '62.c', '77.c', '79.c', '108.c', '129.c', '34.c']
