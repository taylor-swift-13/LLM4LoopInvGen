file:13.c
Successfully generated loop/13.json
INNER_FLAG: False
Variable Maps: [{'z3': 'z3@pre', 'z2': 'z2@pre', 'z1': 'z1@pre', 'y': 'y@pre', 'x': 'x@pre'}]
Path conditions: ['x@pre >= 0 && x@pre <= 2 && y@pre <= 2 && y@pre >= 0']
Pre condition: x@pre >= 0 && x@pre <= 2 && y@pre <= 2 && y@pre >= 0 && (z3 == z3@pre) * (z2 == z2@pre) * (z1 == z1@pre) * (y == y@pre) * (x == x@pre)
Loop Condition: unknown()
Updated Loop Conditions: ['unknown()']
Global Unchanged Variables ['z3', 'z2', 'z1']
Non Inductive Variables []
[{'z3': 'z3@pre', 'z2': 'z2@pre', 'z1': 'z1@pre', 'y': 'y@pre', 'x': 'x@pre'}]
['x@pre >= 0 && x@pre <= 2 && y@pre <= 2 && y@pre >= 0']

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : \at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0 && (z3 == \at(z3, Pre)) * (z2 == \at(z2, Pre)) * (z1 == \at(z1, Pre)) * (y == \at(y, Pre)) * (x == \at(x, Pre)) <<< */
    
            /*@
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : \at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0 && (z3 == \at(z3, Pre)) * (z2 == \at(z2, Pre)) * (z1 == \at(z1, Pre)) * (y == \at(y, Pre)) * (x == \at(x, Pre)) <<< */
    
            /*@
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || (PLACE_HOLDER_x)) ;
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || (PLACE_HOLDER_y)) ;
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
int unknown();
/*@ requires x >= 0 && x <= 2 && y <= 2 && y >= 0; */
void foo(int x,int y,int z1,int z2,int z3) {

  
    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : \at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0 && (z3 == \at(z3, Pre)) * (z2 == \at(z2, Pre)) * (z1 == \at(z1, Pre)) * (y == \at(y, Pre)) * (x == \at(x, Pre)) <<< */
    
            /*@
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || (PLACE_HOLDER_x)) ;
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || (PLACE_HOLDER_y)) ;
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
  
      /*@ assert (x == 4) ==> (y != 0);  */
  
  }
<think>Let me analyze this C program to identify the appropriate loop invariants. First, I need to understand what the program does.

The program has the following structure:
- Function `foo` takes parameters `x`, `y`, `z1`, `z2`, and `z3`.
- The precondition specifies that `x` is between 0 and 2 (inclusive) and `y` is between 0 and 2 (inclusive).
- There's a loop with an unknown condition (meaning it could iterate any number of times or not at all).
- Inside the loop, `x` is incremented by 2 and `y` is incremented by 2 in each iteration.
- The postcondition (represented by the assert) states that if `x == 4`, then `y != 0`.

The placeholders I need to fill are:
- PLACE_HOLDER_x: A condition related to the value of x during the loop execution.
- PLACE_HOLDER_y: A condition related to the value of y during the loop execution.

Now, let's analyze how `x` and `y` evolve in the loop:
- Both `x` and `y` are incremented by 2 in each iteration.
- Given the precondition, initially `x` is between 0 and 2, and `y` is between 0 and 2.

For the invariant to be useful in proving the postcondition, it should capture the relationship between `x` and `y` during loop execution. Since both are incremented by the same amount (2) in each iteration, they maintain a fixed difference throughout the loop.

The difference between `x` and `y` can be expressed as `x - y`. Initially, this difference is between -2 and 2 (since x is in [0,2] and y is in [0,2]). Since both x and y increase by the same amount in each iteration, this difference remains constant.

Let's think about the postcondition: if `x == 4`, then `y != 0`.

The invariant needs to capture the evolving values of `x` and `y`. Since both start in the range [0,2] and increase by 2 in each iteration, for `x` to reach 4, it would need at least one iteration if it started at 2, or two iterations if it started at 0.

Similarly, for `y`, if it starts at 0, after one iteration it would be 2, and after two iterations it would be 4. If it starts at 2, after one iteration it would be 4.

So, we need to express that after any number of iterations, there's a relationship between the current values of `x` and `y` and their initial values.

Let me define the invariants:

For `x`: `x == \at(x, Pre) + 2 * n` where `n` is the number of iterations. This expresses that x increases by 2 after each iteration.
For `y`: `y == \at(y, Pre) + 2 * n` where `n` is the same number of iterations. This expresses that y increases by 2 after each iteration.

However, since the loop uses `unknown()` as its condition, we don't know how many iterations it will perform. But we can derive a relationship between `x` and `y`:

If we eliminate `n` from both equations, we get: `x - \at(x, Pre) = y - \at(y, Pre)`, which can be rearranged to: `x - y = \at(x, Pre) - \at(y, Pre)`.

This means the difference between `x` and `y` remains constant throughout the loop.

Additionally, we also know that both `x` and `y` are monotonically increasing (they never decrease), and they increase by 2 in each iteration. So, we can derive:
- `x >= \at(x, Pre)`
- `y >= \at(y, Pre)`
- `x - \at(x, Pre) = y - \at(y, Pre)`

Now, let's express these in the invariant format:

For `PLACE_HOLDER_x`: `x >= \at(x, Pre) && (x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre))`
For `PLACE_HOLDER_y`: `y >= \at(y, Pre) && (y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre))`

These invariants capture the fact that `x` and `y` both increase by even amounts (2 per iteration) and they maintain a constant difference.

Let's check if these invariants are sufficient to prove the postcondition:

The postcondition states that if `x == 4`, then `y != 0`.

If `x == 4`, using our invariant, we can derive:
- `x >= \at(x, Pre)` implies that `4 >= \at(x, Pre)`.
- Since `\at(x, Pre) <= 2` from the precondition, we know that at least one iteration of the loop has occurred (if `\at(x, Pre) == 2`, then one iteration makes `x = 4`; if `\at(x, Pre) < 2`, then more iterations are needed).
- From the invariant `(x - \at(x, Pre)) == (y - \at(y, Pre))`, we get `4 - \at(x, Pre) = y - \at(y, Pre)`, which gives us `y = \at(y, Pre) + (4 - \at(x, Pre))`.
- Now, if `\at(y, Pre) == 0` and `\at(x, Pre) == 0`, then `y = 0 + (4 - 0) = 4`. Thus, if `x == 4` and `\at(x, Pre) == 0` and `\at(y, Pre) == 0`, then `y == 4 != 0`, satisfying the postcondition.
- If `\at(y, Pre) > 0`, then `y > 0 + (4 - \at(x, Pre)) > 0` (since `\at(x, Pre) <= 2`), which again satisfies the postcondition.

But there seems to be a case I haven't covered: what if `\at(y, Pre) == 0` and `\at(x, Pre) == 2`? In this case, after one iteration, `x = 4` and `y = 2`, still satisfying `y != 0`. But this isn't directly evident from the invariants I've defined.

Let's refine the invariants to be more precise about the relationship between `x` and `y`:

For `PLACE_HOLDER_x`: 
`(x == \at(x, Pre) + 2 * k && k >= 0 && \integer k)` - This states that x has increased by 2*k for some non-negative integer k.

For `PLACE_HOLDER_y`: 
`(y == \at(y, Pre) + 2 * k && k >= 0 && \integer k)` - Similarly for y.

Now, let's verify if these invariants are sufficient to prove the postcondition:

If `x == 4`, then `4 = \at(x, Pre) + 2 * k`. Given that `\at(x, Pre) <= 2`, we know that `k >= 1` (at least one iteration has occurred).

Similarly, `y = \at(y, Pre) + 2 * k`. Since `k >= 1` and `\at(y, Pre) >= 0`, we know that `y >= 2*1 = 2`. Thus, `y != 0`, satisfying the postcondition.

Actually, there's an issue with my reasoning above. Let me reconsider. The invariant doesn't say "for all k", but for the specific k (number of iterations) that has occurred up to the current point in the execution. To be more precise, I need to express that both `x` and `y` increase by the same amount (2 times the number of iterations).

For `PLACE_HOLDER_x`: `(x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && x >= \at(x, Pre)`
For `PLACE_HOLDER_y`: `(y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && y >= \at(y, Pre)`

These invariants express that both `x` and `y` increase by even amounts, they increase by the same amount, and they are both greater than or equal to their initial values.

Let's check these invariants against the postcondition:

If `x == 4`, then:
- `(4 - \at(x, Pre)) == (y - \at(y, Pre))` (from the invariant)
- `y = \at(y, Pre) + (4 - \at(x, Pre))`
- Since `\at(x, Pre) <= 2` (from the precondition), we know that `(4 - \at(x, Pre)) >= 2`.
- Thus, `y >= \at(y, Pre) + 2 >= 0 + 2 = 2` (using `\at(y, Pre) >= 0`).
- Hence, `y >= 2 > 0`, which satisfies the postcondition.

I think these invariants are sufficient to prove the postcondition. Let's clean them up for the final form:

For `PLACE_HOLDER_x`: `((x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && x >= \at(x, Pre))`
For `PLACE_HOLDER_y`: `((y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && y >= \at(y, Pre))`</think>

# Analysis of Loop Program with Invariants for Frama-C Verification

## a. Purpose and Structure of the Loop

**Purpose:** The loop increments both `x` and `y` by 2 in each iteration, potentially running for an arbitrary number of times controlled by the unknown() function.

**Structure:**
- Loop condition: `unknown()` - can return any value, making the number of iterations unpredictable
- Loop body: Increments both `x` and `y` by 2 in each iteration
- Relevant variables: `x` and `y` (modified in the loop), and `z1`, `z2`, `z3` (unchanged throughout)
- Pre-condition: `x` and `y` both start in the range [0,2]
- Post-condition: If `x` equals 4, then `y` must not equal 0

## b. Discussion of the Loop Invariant

The proposed loop invariants capture three key aspects:
1. The relationship between the current and initial values of `x` and `y`
2. The fact that both variables increase by the same amount in each iteration
3. The fact that `z1`, `z2`, and `z3` remain unchanged throughout execution

The invariant is valid because it holds before the loop starts, is preserved by each iteration, and helps establish the post-condition when the loop terminates.

## c. Establishment

Before the loop starts, `x`, `y`, `z1`, `z2`, and `z3` all equal their initial values. The invariant is trivially established since the first part of the OR condition is true: `(z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))`.

## d. Preservation

When the loop executes:
- Both `x` and `y` increase by 2
- The difference `x - \at(x, Pre)` equals `y - \at(y, Pre)` after each iteration
- Both increments are always multiples of 2
- `z1`, `z2`, and `z3` remain unchanged

These properties are maintained by each iteration, preserving the invariant.

## e. Termination Analysis

When the loop terminates (when `unknown()` returns a falsy value), the invariant still holds. At this point:
- `x` equals `\at(x, Pre) + 2n` where n is the number of iterations (n ≥ 0)
- `y` equals `\at(y, Pre) + 2n` with the same n
- `z1`, `z2`, and `z3` still equal their initial values

## f. Correctness of the Post-condition

The post-condition asserts that `(x == 4) ==> (y != 0)`. Let's verify this:

If `x == 4`, then given the pre-condition `\at(x, Pre) ≤ 2`, the loop must have executed at least once. Since `x` equals `\at(x, Pre) + 2n`, we have:
- 4 = \at(x, Pre) + 2n
- Therefore 2n = 4 - \at(x, Pre) ≥ 2 (since \at(x, Pre) ≤ 2)
- n ≥ 1

From our invariant, `y = \at(y, Pre) + 2n`. Since `\at(y, Pre) ≥ 0` and n ≥ 1, we have:
- y ≥ 0 + 2(1) = 2

Therefore, `y ≥ 2`, which means `y != 0`, satisfying the post-condition.

## g. Implication of the Pre-condition

The pre-condition guarantees that `x` and `y` start in the range [0,2] and all variables initially equal their Pre values. This directly establishes the left-hand side of the invariant. The right-hand side is established because before the loop starts, all variables equal their Pre values, making the first part of the OR condition true.

## Complete C Loop Program with Filled Invariants

```c
int unknown();
/*@ requires x >= 0 && x <= 2 && y <= 2 && y >= 0; */
void foo(int x,int y,int z1,int z2,int z3) {

  
    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : \at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0 && (z3 == \at(z3, Pre)) * (z2 == \at(z2, Pre)) * (z1 == \at(z1, Pre)) * (y == \at(y, Pre)) * (x == \at(x, Pre)) <<< */
    
            /*@
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && x >= \at(x, Pre))) ;
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && y >= \at(y, Pre))) ;
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
  
      /*@ assert (x == 4) ==> (y != 0);  */
  
  }
```

int unknown();
/*@ requires x >= 0 && x <= 2 && y <= 2 && y >= 0; */
void foo(int x,int y,int z1,int z2,int z3) {

  
    
            
            /*@
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && x >= \at(x, Pre))) ;
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && y >= \at(y, Pre))) ;
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
  
      /*@ assert (x == 4) ==> (y != 0);  */
  
  }


int unknown();
/*@ requires x >= 0 && x <= 2 && y <= 2 && y >= 0; */
void foo(int x,int y,int z1,int z2,int z3) {

  
    
            
            /*@
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((x - \at(x, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && x >= \at(x, Pre))) ;
          loop invariant  (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (((z3 == \at(z3, Pre))&&(z2 == \at(z2, Pre))&&(z1 == \at(z1, Pre))&&(y == \at(y, Pre))&&(x == \at(x, Pre))) || ((y - \at(y, Pre)) % 2 == 0 && (x - \at(x, Pre)) == (y - \at(y, Pre)) && y >= \at(y, Pre))) ;
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z3 == \at(z3, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z2 == \at(z2, Pre));
          loop invariant (\at(x, Pre) >= 0 && \at(x, Pre) <= 2 && \at(y, Pre) <= 2 && \at(y, Pre) >= 0) ==> (z1 == \at(z1, Pre));
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
  
      /*@ assert (x == 4) ==> (y != 0);  */
  
  }

syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[True]

CORRECT INVARIANT
syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[True]

syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[True]

已移动文件: 13.c -> finish
-----------------------------------------

文件 13.c 处理完成. 总耗时: 105.46709752082825
-----------------------------------------
finshed_files:['132.c', '70.c', '121.c', '94.c', '109.c', '61.c', '120.c', '42.c', '33.c', '17.c', '105.c', '101.c', '38.c', '40.c', '88.c', '4.c', '114.c', '8.c', '84.c', '83.c', '111.c', '47.c', '14.c', '49.c', '131.c', '119.c', '43.c', '50.c', '56.c', '18.c', '53.c', '35.c', '10.c', '28.c', '26.c', '73.c', '89.c', '126.c', '96.c', '57.c', '37.c', '36.c', '92.c', '68.c', '115.c', '71.c', '91.c', '22.c', '19.c', '124.c', '52.c', '100.c', '95.c', '90.c', '86.c', '128.c', '62.c', '77.c', '79.c', '108.c', '129.c', '34.c', '123.c', '98.c', '41.c', '27.c', '106.c', '58.c', '130.c', '20.c', '85.c', '15.c', '75.c', '104.c', '2.c', '82.c', '32.c', '23.c', '117.c', '125.c', '64.c', '6.c', '1.c', '12.c', '45.c', '113.c', '13.c']
