file:03.c
TRY TIME: 0
[(98, 165, 0), (131, 158, 1)]
[(98, 165, 0), (131, 158, 1)]
[(98, 165, 0), (131, 158, 1)]
[(98, 165, 0), (131, 158, 1)]
Loop 1 : Inner
Loop 0 : Outer
Sorted indices: [1, 0]
File found: ../sac_c_parser/test/../ip_postcond/goal/03_goal.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/03_proof_auto.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/03_proof_manual.v. Deleting the file.
LoopEntry_0:
l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)
LoopEntry_1:
1 < n@pre && l@pre > 0 && n@pre > l@pre && (k == 1) * (i == l@pre) * (l == l@pre) * (n == n@pre)

[(0, 'l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)'), (1, '1 < n@pre && l@pre > 0 && n@pre > l@pre && (k == 1) * (i == l@pre) * (l == l@pre) * (n == n@pre)')]
Successfully generated loop/03.json
INNER_FLAG: True
Variable Maps: [{'k': '1', 'i': 'l@pre', 'l': 'l@pre', 'n': 'n@pre'}]
Path conditions: ['1 < n@pre && l@pre > 0 && n@pre > l@pre']
Pre condition: 1 < n@pre && l@pre > 0 && n@pre > l@pre && (k == 1) * (i == l@pre) * (l == l@pre) * (n == n@pre)
Loop Condition: i<n
Updated Loop Conditions: ['l@pre<n@pre']
Global Unchanged Variables ['k', 'l', 'n']
Non Inductive Variables []
[{'k': '1', 'i': 'l@pre', 'l': 'l@pre', 'n': 'n@pre'}]
['1 < n@pre && l@pre > 0 && n@pre > l@pre']


/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  for (k=1; k<n; k++){
  	i = l;
    
                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
                /*@
           PLACE_HOLDER_FOR_LOOP 
                */
                for (i=l; i<n; i++) {
    }
                

    }
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

SIMPLE
```c
/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  for (k=1; k<n; k++){
  	i = l;
    
                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

```

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}



/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}


INNER_FLAG: False
Variable Maps: [{'k': '1', 'l': 'l@pre', 'n': 'n@pre'}]
Path conditions: ['l@pre > 0 && n@pre > l@pre']
Pre condition: l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)
Loop Condition: k<n
Updated Loop Conditions: ['1<n@pre']
Global Unchanged Variables ['l', 'n']
Non Inductive Variables []
[{'k': '1', 'l': 'l@pre', 'n': 'n@pre'}]
['l@pre > 0 && n@pre > l@pre']

                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                

                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
                /*@
          loop invariant  (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (PLACE_HOLDER_k))) ;
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
                /*@
          loop invariant  (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (PLACE_HOLDER_k))) ;
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}


```c
/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
        /* >>> LOOP INVARIANT TO FILL <<< */
        
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre)));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}
```

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre)));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}


/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre)));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

syntax Error
[kernel] Parsing output/03.c (with preprocessing)
[kernel:annot-error] output/03.c:13: Warning: unexpected token ';'
[kernel] User Error: warning annot-error treated as fatal error.
[kernel] Frama-C aborted: invalid user input.

after repair

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n)));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant l <= i < n;
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

syntax Correct
Validate:
[True, True, True, True, False, True]

Goal Preservation of Invariant (file output/03.c, line 23)
Error found in file: output/03.c at line: 23
Error line content: loop invariant l <= i < n;

Verify:
[True]

after hudini

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n)));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

syntax Correct
Validate:
[False, True, True, True, True]

Goal Preservation of Invariant (file output/03.c, line 13)
Error found in file: output/03.c at line: 13
Error line content: loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((1<\at(n, Pre)) ==> (((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))) || (k < n)));

Verify:
[True]

after hudini

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

syntax Correct
Validate:
[True, True, True, True]

Verify:
[True]

after hudini

/*@
requires l > 0;
requires n > l;
*/
void foo(int n, int l) {
  int i,k;

  k = 1;
  
                
                /*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
                
  
    /*@ assert \forall integer i; (l <= i < n) ==> (1 <= i); */
  

}

syntax Correct
Validate:
[True, True, True, True]

Verify:
[True]

/*@
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> ((!(1<\at(n, Pre))) ==> ((k == 1)&&(l == \at(l, Pre))&&(n == \at(n, Pre))));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (l == \at(l, Pre));
          loop invariant (\at(l, Pre) > 0 && \at(n, Pre) > \at(l, Pre)) ==> (n == \at(n, Pre));
                */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@
        loop invariant 1 <= i <= n;
        loop assigns i;
        */
        for (i=l; i<n; i++) {
    }
                

    }
转换后
/*@ Inv
    ((l@pre > 0 && n@pre > l@pre) => ((!(1<n@pre)) => ((k == 1)&&(l == l@pre)&&(n == n@pre)))) &&
((l@pre > 0 && n@pre > l@pre) => (l == l@pre)) &&
((l@pre > 0 && n@pre > l@pre) => (n == n@pre))
    */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@ Inv
    (1 <= i && i <= n
        loop assigns i)
    */
        for (i=l; i<n; i++) {
    }
                

    }
PARTIAL CORRECT INVARIANT
继续符号执行
/*@ Inv
    ((l@pre > 0 && n@pre > l@pre) => ((!(1<n@pre)) => ((k == 1)&&(l == l@pre)&&(n == n@pre)))) &&
((l@pre > 0 && n@pre > l@pre) => (l == l@pre)) &&
((l@pre > 0 && n@pre > l@pre) => (n == n@pre))
    */
                for (k=1; k<n; k++){
  	i = l;
    
                
        /*@ Inv
    (1 <= i && i <= n
        loop assigns i)
    */
        for (i=l; i<n; i++) {
    }
                

    }
File found: ../sac_c_parser/test/../ip_postcond/goal/03_goal.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/03_proof_auto.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/03_proof_manual.v. Deleting the file.
LoopEntry_0:
l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)
[1;31mfatal error: [0mbison: syntax error, unexpected PT_IDENT, expecting PT_RPAREN or PT_COLON in ../../LoopInvGen_8/symexe/output/03.c:23:12
['for (k=1; k<n; k++){\n  \ti=l;\n    for (i=l; i<n; i++) {\n    }\n\n    }', 'for (i=l; i<n; i++) {\n    }']
[(0, 'l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)')]
diff
1
1
[(0, 'l@pre > 0 && n@pre > l@pre && (k == 1) * undef_data_at(&i) * (l == l@pre) * (n == n@pre)'), (1, '')]
Successfully generated loop/03.json
syntax Correct
Validate:
[True, True, True, True]

Verify:
[True]

CORRECT INVARIANT
syntax Correct
Validate:
[True, True, True, True]

Verify:
[True]

已移动文件: 03.c -> finish
-----------------------------------------

文件 03.c 处理完成. 总耗时: 102.61460590362549
所有文件验证通过，没有错误文件。
========================================
所有文件验证通过，没有错误文件。
========================================
所有文件验证通过，没有错误文件。
========================================
-----------------------------------------
finshed_files:['03.c']
