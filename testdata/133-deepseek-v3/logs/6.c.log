file:6.c
Successfully generated loop/6.json
INNER_FLAG: False
Variable Maps: [{'x': '0', 'z': 'z@pre', 'y': 'y@pre', 'size': 'size@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre'}]
Path conditions: [None]
Pre condition: (x == 0) * (z == z@pre) * (y == y@pre) * (size == size@pre) * (v3 == v3@pre) * (v2 == v2@pre) * (v1 == v1@pre)
Loop Condition: x < size
Updated Loop Conditions: ['0 < size@pre']
Global Unchanged Variables ['z', 'size', 'v3', 'v2', 'v1']
Non Inductive Variables ['y']
[{'x': '0', 'z': 'z@pre', 'y': 'y@pre', 'size': 'size@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre'}]
[None]

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_y));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_y));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}
### Analysis

#### a. Purpose and Structure of the Loop
The loop's objective is to iterate from `x = 0` to `x = size - 1` (inclusive) and, in each iteration, update `y` to be the minimum of its current value and `z`. The loop condition is `x < size`, and the loop increments `x` by 1 in each iteration. The relevant variables are:
- `x`: Loop counter, initialized to 0.
- `size`: Upper bound for the loop counter.
- `y`: Variable that may be updated to the minimum of `y` and `z`.
- `z`: Constant value compared with `y`.
- `v1`, `v2`, `v3`: Additional variables that remain unchanged.

#### b. Discussion of the Loop Invariant
The loop invariant must capture:
1. The relationship between `x`, `size`, and the loop's progress.
2. The fact that `y` is always less than or equal to its initial value or `z`.
3. The constancy of `z`, `size`, `v1`, `v2`, and `v3`.

The proposed invariant splits into two cases:
- If `size > 0`, then either the loop hasn't started (`x == 0` and all variables are at their initial values) or the loop has started (`x > 0` and `y` is updated correctly).
- If `size <= 0`, the loop doesn't run, and all variables remain at their initial values.

#### c. Establishment
Before the loop starts, `x == 0`, and all other variables are at their initial values (per the pre-condition). Thus, the first part of the invariant (`x == 0 && ...`) holds. The other invariants (e.g., `z == \at(z, Pre)`) also hold because the pre-condition guarantees them.

#### d. Preservation
Assume the invariant holds at the start of an iteration where `x < size`:
- If `x == 0`, the loop body increments `x` to 1 and updates `y` if `z <= y`. Thus, after the iteration, `x > 0`, and `y` is the minimum of its initial value and `z`. The invariant still holds because `y` is correctly updated.
- If `x > 0`, the loop body increments `x` and updates `y` if needed. The invariant holds because `y` remains the minimum of its initial value and `z`.

#### e. Termination Analysis
When the loop terminates, `x >= size`. If `size > 0`, then `x == size` (since `x` increments by 1 each time). The invariant ensures that `y` is the minimum of its initial value and `z` over all iterations. If `size <= 0`, the loop doesn't run, and all variables remain at their initial values.

#### f. Correctness of the Post-condition
The post-condition `(size > 0) ==> (z >= y)` holds because:
- If `size > 0`, the loop runs, and `y` is updated to the minimum of its initial value and `z`. Thus, `z >= y` at the end.
- If `size <= 0`, the post-condition is vacuously true (the implication holds because the premise is false).

#### g. Implication of the Pre-condition
The pre-condition guarantees that all variables are at their initial values (`x == 0`, `y == \at(y, Pre)`, etc.). This directly implies the loop invariant's initial state (`x == 0 && ...`).

### Filled-in Loop Invariants
```c
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y == \at(y, Pre) || y == z) && (x > 0)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}
```

### Explanation of Filled Placeholders
- `PLACE_HOLDER_y`: `(y == \at(y, Pre) || y == z) && (x > 0)`
  - Ensures `y` is either its initial value or `z` (the minimum) after the loop starts (`x > 0`).
- `PLACE_HOLDER_x`: `(0 < x && x <= size)`
  - Ensures `x` is within bounds after the loop starts (`x > 0`).

These invariants are sufficient to prove the post-condition.

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y == \at(y, Pre) || y == z) && (x > 0)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}


void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y == \at(y, Pre) || y == z) && (x > 0)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True]

Verify:
[False]

Goal Assertion (file output/6.c, line 27):
Assume {
  Type: is_sint32(size_0) /\ is_sint32(x) /\ is_sint32(y_1) /\
      is_sint32(y) /\ is_sint32(z).
  (* Goal *)
  When: 0 < size_0.
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ ((y = y_1) \/ (z = y))).
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ (x <= size_0)).
  (* Else *)
  Have: size_0 <= x.
}
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:5ms) (3s)
Error found in file: output/6.c at line: 27
Error line content: /*@ assert (size > 0) ==> (z >= y);  */

### Error Analysis:

The error message indicates that the post-condition `(size > 0) ==> (z >= y)` cannot be verified with the current loop invariants. The prover times out when trying to prove that `y <= z` when `size > 0`.

The issue is that while the current invariants track the relationship between `y` and `z` (`y == \at(y, Pre) || y == z`), they don't establish that `y` is always less than or equal to `z` after any modification. The loop's `if` statement ensures that `y` can only decrease (when `z <= y`), but we need to explicitly state in the invariant that `y` is always less than or equal to its initial value or equal to `z`.

### Fixed C Code:

```c
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z)) && (x > 0)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}
```

The key change is in the first loop invariant, where we've strengthened the condition to include `y <= \at(y, Pre)` in addition to the existing conditions. This ensures that:
1. `y` never exceeds its initial value
2. `y` is either equal to its initial value or equal to `z` (from the original condition)
3. When combined with the fact that `z` never changes (from another invariant), this guarantees that in the post-condition, `y` must be less than or equal to `z` when the loop has executed (i.e., when `size > 0`).

This modification provides the necessary information for the prover to establish the post-condition without changing the actual behavior of the program.
after strength

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z)) && (x > 0)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True]

Verify:
[False]

Goal Assertion (file output/6.c, line 27):
Assume {
  Type: is_sint32(size_0) /\ is_sint32(x) /\ is_sint32(y_1) /\
      is_sint32(y) /\ is_sint32(z).
  (* Goal *)
  When: 0 < size_0.
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/
      ((0 < x) /\ (y <= y_1) /\ ((y = y_1) \/ (z = y))).
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ (x <= size_0)).
  (* Else *)
  Have: size_0 <= x.
}
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:5ms) (3s)
Error found in file: output/6.c at line: 27
Error line content: /*@ assert (size > 0) ==> (z >= y);  */

### Error Analysis

The error message indicates that the prover cannot verify the post-condition `(size > 0) ==> (z >= y)` with the current loop invariants. The key issue is that while the invariants track the relationship between `y` and its initial value or `z`, they don't sufficiently constrain `y` to prove that it must be less than or equal to `z` when the loop terminates.

The current invariants state:
1. `y` is either equal to its initial value or equal to `z`
2. `y` is less than or equal to its initial value
3. `x` is between 0 and `size`

However, to prove `z >= y` at the end, we need to strengthen the invariant to explicitly state that `y <= z` holds throughout the loop. This is because:
- Initially, either `y` equals its initial value (but we don't know its relation to `z`)
- Or `y` gets set to `z` (making `y == z`)
- But we need to ensure that in all cases, `y <= z`

### Fixed C Code

```c
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && y <= z) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z;
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}
```

The key changes are:
1. Added `y <= z` to the first invariant's disjunct for the case when `x > 0`
2. Added a separate `loop invariant y <= z` to make this property explicitly available to the prover

This ensures that:
- Initially, if `x == 0`, then `y` equals its initial value and we don't need the property
- After first iteration, either:
  - `y` remains unchanged (so we need to assume `y <= z` from pre-condition)
  - Or `y` is set to `z` (making `y == z`)
- In all cases, `y <= z` is maintained
- At loop exit, this directly proves the post-condition `z >= y` when `size > 0`

The additional invariant is simple but crucial for establishing the post-condition.
after strength

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && y <= z) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z;
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True, False]

Goal Establishment of Invariant (file output/6.c, line 15):
Assume { Type: is_sint32(y) /\ is_sint32(z). }
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:3ms) (3s)
Error found in file: output/6.c at line: 15
Error line content: loop invariant y <= z;

Verify:
[True]


void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && y <= z) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z [INVARIANT FAILED] ;
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}

### Error Analysis ###

The error message indicates that **"Goal Establishment of Invariant"** is failing for the loop invariant `y <= z`. This means that Frama-C cannot prove that the invariant `y <= z` holds when the loop starts. Specifically, the pre-condition does not provide enough information to guarantee that `y <= z` is true before the loop begins execution.

The invariant `y <= z` is intended to ensure that `y` is always less than or equal to `z` throughout the loop. However, the pre-condition does not explicitly state any relationship between `y` and `z`, so Frama-C cannot establish this invariant initially. To fix this, we need to weaken the invariant to make it compatible with the pre-condition or add additional information to the pre-condition. Since we are only allowed to modify the ACSL annotations and not the pre-condition, we will weaken the invariant.

### Rationale for Modification ###

The invariant `y <= z` is too strong to establish at the start of the loop because the pre-condition does not guarantee any relationship between `y` and `z`. Instead, we can weaken the invariant to state that `y` is either less than or equal to `z` or equal to its initial value. This way, the invariant can be established at the start of the loop because `y` is equal to its initial value (`\at(y, Pre)`), and the invariant becomes `y <= z || y == \at(y, Pre)`.

### Fixed C Code ###

```c
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && (y <= z || y == \at(y, Pre))) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z || y == \at(y, Pre);
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}
```

### Explanation of Changes ###

1. **Weakened the Invariant `y <= z`**: The invariant `y <= z` was replaced with `y <= z || y == \at(y, Pre)`. This ensures that the invariant holds at the start of the loop because `y` is equal to its initial value (`\at(y, Pre)`), satisfying the `y == \at(y, Pre)` condition.

2. **Preserved Other Invariants**: All other invariants remain unchanged, as they are already correct and sufficient for verifying the post-condition.

This modification ensures that the invariant can be established at the start of the loop while still being strong enough to prove the post-condition `(size > 0) ==> (z >= y)` after the loop terminates.
after weaken

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && (y <= z || y == \at(y, Pre))) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z || y == \at(y, Pre);
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True, True]

Verify:
[False]

Goal Assertion (file output/6.c, line 24):
Assume {
  Type: is_sint32(size_0) /\ is_sint32(x) /\ is_sint32(y_1) /\
      is_sint32(y) /\ is_sint32(z).
  (* Goal *)
  When: 0 < size_0.
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/
      ((0 < x) /\ (y <= y_1) /\ ((y = y_1) \/ (z = y))).
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ (x <= size_0)).
  (* Invariant *)
  Have: (y = y_1) \/ (y <= z).
  (* Else *)
  Have: size_0 <= x.
}
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:5ms) (3s)
Error found in file: output/6.c at line: 24
Error line content: /*@ assert (size > 0) ==> (z >= y);  */

after hudini

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    int x = 0;
    
    /*@
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((y <= \at(y, Pre) && (y == \at(y, Pre) || y == z) && (y <= z || y == \at(y, Pre))) && (x > 0)));
      loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || ((0 < x && x <= size)));
      loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
      loop invariant z == \at(z, Pre);
      loop invariant size == \at(size, Pre);
      loop invariant v3 == \at(v3, Pre);
      loop invariant v2 == \at(v2, Pre);
      loop invariant v1 == \at(v1, Pre);
      loop invariant y <= z || y == \at(y, Pre);
    */
    while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
    
    /*@ assert (size > 0) ==> (z >= y);  */
}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True, True]

Verify:
[False]

Goal Assertion (file output/6.c, line 24):
Assume {
  Type: is_sint32(size_0) /\ is_sint32(x) /\ is_sint32(y_1) /\
      is_sint32(y) /\ is_sint32(z).
  (* Goal *)
  When: 0 < size_0.
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/
      ((0 < x) /\ (y <= y_1) /\ ((y = y_1) \/ (z = y))).
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ (x <= size_0)).
  (* Invariant *)
  Have: (y = y_1) \/ (y <= z).
  (* Else *)
  Have: size_0 <= x.
}
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:5ms) (3s)
Error found in file: output/6.c at line: 24
Error line content: /*@ assert (size > 0) ==> (z >= y);  */

syntax Correct
Validate:
[True, True, True, True, True, True, True, True, True]

Verify:
[False]

Goal Assertion (file output/6.c, line 24):
Assume {
  Type: is_sint32(size_0) /\ is_sint32(x) /\ is_sint32(y_1) /\
      is_sint32(y) /\ is_sint32(z).
  (* Goal *)
  When: 0 < size_0.
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/
      ((0 < x) /\ (y <= y_1) /\ ((y = y_1) \/ (z = y))).
  (* Invariant *)
  Have: ((x = 0) /\ (y = y_1)) \/ ((0 < x) /\ (x <= size_0)).
  (* Invariant *)
  Have: (y = y_1) \/ (y <= z).
  (* Else *)
  Have: size_0 <= x.
}
Prove: y <= z.
Prover Z3 4.8.12 returns Timeout (Qed:5ms) (3s)
Error found in file: output/6.c at line: 24
Error line content: /*@ assert (size > 0) ==> (z >= y);  */

[(124, 209, 0)]
[(124, 209, 0)]
[(124, 209, 0)]
[(124, 209, 0)]
Loop 0 : Outer
Sorted indices: [0]
File found: ../sac_c_parser/test/../ip_postcond/goal/6_goal.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/6_proof_auto.v. Deleting the file.
File found: ../sac_c_parser/test/../ip_postcond/goal/6_proof_manual.v. Deleting the file.
LoopEntry_0:
(x == 0) * (z == z@pre) * (y == y@pre) * (size == size@pre) * (v3 == v3@pre) * (v2 == v2@pre) * (v1 == v1@pre)

Successfully generated loop/6.json
INNER_FLAG: False
Variable Maps: [{'x': '0', 'z': 'z@pre', 'y': 'y@pre', 'size': 'size@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre'}]
Path conditions: [None]
Pre condition: (x == 0) * (z == z@pre) * (y == y@pre) * (size == size@pre) * (v3 == v3@pre) * (v2 == v2@pre) * (v1 == v1@pre)
Loop Condition: x < size
Updated Loop Conditions: ['0 < size@pre']
Global Unchanged Variables ['z', 'size', 'v3', 'v2', 'v1']
Non Inductive Variables ['y']
[{'x': '0', 'z': 'z@pre', 'y': 'y@pre', 'size': 'size@pre', 'v3': 'v3@pre', 'v2': 'v2@pre', 'v1': 'v1@pre'}]
[None]

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_y));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_y));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (PLACE_HOLDER_x));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}
# Analysis of the Loop Program

## a. Purpose and Structure of the Loop
The loop's objective is to find the minimum value between `y` and `z` by comparing them in each iteration and updating `y` if `z` is smaller. The loop iterates `size` times (controlled by counter `x`), and after completion, the post-condition asserts that if `size > 0`, then `z` must be greater than or equal to `y` (meaning `y` contains the minimum value).

Loop structure:
- Loop condition: `x < size`
- Loop variable: `x` (incremented each iteration)
- Relevant variables: `x`, `y`, `z`, `size`, `v1`, `v2`, `v3`
- Loop body: Increments `x` and updates `y` to `z` if `z <= y`

## b. Discussion of the Loop Invariant
The proposed invariant maintains that:
1. Either we're in the initial state (all variables equal their pre-state values) OR `y` has been potentially updated to be the minimum between original `y` and `z`
2. Either we're in the initial state OR `x` has been incremented
3. If size is not positive, all variables remain at their initial values
4. Several variables (`z`, `size`, `v1`, `v2`, `v3`) remain unchanged throughout

## c. Establishment
Before the loop starts (when `x == 0`), the first branch of each disjunctive invariant is true because all conditions match the pre-state, satisfying the establishment condition.

## d. Preservation
For each iteration:
- If `z <= y`, `y` is updated to `z` (the minimum value)
- `x` is always incremented
- The unchanged variables remain unchanged
Thus, the invariant remains true at the end of each iteration.

## e. Termination Analysis
When the loop terminates, `x == size`. The invariant still holds because:
- Either we never entered the loop (if `size <= 0`)
- Or we've performed all iterations, maintaining the invariant properties

## f. Correctness of the Post-condition
The post-condition `(size > 0) ==> (z >= y)` is correct because:
- The invariant ensures `y` is always the minimum between original `y` and `z`
- When the loop terminates, `y` contains this minimum value
- Therefore, `z` must be greater than or equal to `y`

## g. Implication of the Pre-condition
The pre-condition directly matches the initial state required by the invariant (when `x == 0`), guaranteeing the invariant holds before loop execution begins.

# Complete Program with Filled Invariants

```c
void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
    /* >>> LOOP INVARIANT TO FILL <<< 
       >>> PRECONDITION OF THE LOOP : (x == 0) * (z == \at(z, Pre)) * (y == \at(y, Pre)) * (size == \at(size, Pre)) * (v3 == \at(v3, Pre)) * (v2 == \at(v2, Pre)) * (v1 == \at(v1, Pre)) <<< */
    
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (y == \min(\at(y, Pre), z)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (x > 0));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}
```

Filled placeholders:
- PLACE_HOLDER_y: `y == \min(\at(y, Pre), z)`
- PLACE_HOLDER_x: `x > 0`

void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (y == \min(\at(y, Pre), z)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (x > 0));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}


void foo(int v1, int v2 ,int v3,int size, int y, int z)
{
    
    int x = 0;

    
            
            /*@
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (y == \min(\at(y, Pre), z)));
          loop invariant (0 < \at(size, Pre)) ==> (((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre))) || (x > 0));
          loop invariant (!(0 < \at(size, Pre))) ==> ((x == 0)&&(z == \at(z, Pre))&&(y == \at(y, Pre))&&(size == \at(size, Pre))&&(v3 == \at(v3, Pre))&&(v2 == \at(v2, Pre))&&(v1 == \at(v1, Pre)));
          loop invariant z == \at(z, Pre);
          loop invariant size == \at(size, Pre);
          loop invariant v3 == \at(v3, Pre);
          loop invariant v2 == \at(v2, Pre);
          loop invariant v1 == \at(v1, Pre);
            */
            while(x < size) {
       x += 1;
       if( z <= y) {
          y = z;
       }
    }
            

    /*@ assert (size > 0) ==> (z >= y);  */

}

syntax Correct
Validate:
[True, True, True, True, True, True, True, True]

Verify:
[True]

CORRECT INVARIANT
syntax Correct
Validate:
[True, True, True, True, True, True, True, True]

Verify:
[True]

syntax Correct
Validate:
[True, True, True, True, True, True, True, True]

Verify:
[True]

已移动文件: 6.c -> finish
-----------------------------------------

文件 6.c 处理完成. 总耗时: 444.61944007873535
-----------------------------------------
finshed_files:['11.c', '132.c', '70.c', '121.c', '94.c', '109.c', '61.c', '120.c', '42.c', '33.c', '17.c', '105.c', '101.c', '38.c', '40.c', '88.c', '4.c', '114.c', '8.c', '84.c', '83.c', '111.c', '47.c', '14.c', '49.c', '131.c', '119.c', '43.c', '50.c', '56.c', '18.c', '53.c', '35.c', '10.c', '28.c', '26.c', '73.c', '89.c', '126.c', '96.c', '57.c', '37.c', '36.c', '92.c', '68.c', '115.c', '71.c', '91.c', '22.c', '19.c', '124.c', '52.c', '100.c', '95.c', '90.c', '86.c', '128.c', '62.c', '77.c', '79.c', '108.c', '129.c', '34.c', '123.c', '98.c', '41.c', '27.c', '106.c', '58.c', '130.c', '20.c', '85.c', '15.c', '75.c', '104.c', '2.c', '82.c', '32.c', '23.c', '117.c', '125.c', '64.c', '6.c']
